import{C as M,L as B}from"./web-ifc-api-ub-SNF9_.js";import{a as E,h as S,M as k,n as D,b as v,_ as x,d as I}from"./index-Yrq3EJXu.js";import{d as L}from"./index-CqPyogbW.js";import{Z as A}from"./index-DlcxkA5s.js";import{S as C}from"./stats.min-GTpOrGrX.js";import{J as _,g as J,q as P,h as U,X}from"./index-Bwkk81Gk.js";import"./_commonjsHelpers-Cpj98o6Y.js";L.init();A.init();const y=document.getElementById("container"),e=new E,j=e.get(S),t=j.create();t.scene=new k(e);t.renderer=new _(e,y);t.camera=new D(e);e.init();t.scene.setup();t.camera.controls.setLookAt(5,5,5,0,0,0);y.appendChild(t.renderer.three2D.domElement);const q=e.get(v);q.create(t);t.scene.three.background=null;const b=e.get(x),H=await fetch("https://thatopen.github.io/engine_components/resources/road.frag"),N=await H.arrayBuffer(),W=new Uint8Array(N),i=b.load(W);t.scene.three.add(i);const Z=await fetch("https://thatopen.github.io/engine_components/resources/road.json");i.setLocalProperties(await Z.json());const h=document.getElementById("scene-2d-left");h.components=e;if(!h.world)throw new Error("World not found!");const c=e.get(J);c.world=h.world;await c.draw(i);const l=e.get(P);l.world=t;l.draw(i);const g=document.getElementById("scene-2d-right");g.components=e;if(!g.world)throw new Error("World not found!");const f=e.get(U);f.world=g.world;f.world3D=t;c.onMarkerChange.add(({alignment:o,percentage:n,type:r,curve:s})=>{if(l.setMarker(o,n,r),r==="select"){const d=s.alignment.absolute[s.index].mesh,m=o.getPointAt(n,"absolute");f.set(d,m)}});c.onHighlight.add(({mesh:o})=>{l.highlighter.select(o);const n=o.curve.index,r=o.curve.alignment.absolute[n];r.mesh.geometry.computeBoundingSphere();const s=r.mesh.geometry.boundingSphere;s&&t.camera.controls.fitToSphere(s,!0)});c.onMarkerHidden.add(({type:o})=>{l.hideMarker(o)});const p=e.get(I);p.byEntity(i);const z=p.list,w=e.get(X),u=w.styles.list;for(const o in z.entities){const n=p.find({entities:[o]}),r=new M(Math.random(),Math.random(),Math.random()),s=new B({color:r});w.styles.create(o,new Set,g.world,s);for(const d in n){const m=b.list.get(d);m&&(u[o].fragments[d]=new Set(n[d]),u[o].meshes.add(m.mesh))}}w.update(!0);const a=new C;a.showPanel(2);document.body.append(a.dom);a.dom.style.left="0px";a.dom.style.zIndex="unset";t.renderer.onBeforeUpdate.add(()=>a.begin());t.renderer.onAfterUpdate.add(()=>a.end());
